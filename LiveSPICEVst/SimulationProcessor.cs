using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using Circuit;
using ComputerAlgebra;
using LiveSPICEVst.ViewModels;
using Util;

namespace LiveSPICEVst
{

    /// <summary>
    /// Manages single-channel audio circuit simulation
    /// </summary>
    public class SimulationProcessor
    {
        public ObservableCollection<ComponentViewModel> InteractiveComponents { get; }
        public Schematic Schematic { get; private set; }
        public string SchematicPath { get; private set; }
        public string SchematicName => Path.GetFileNameWithoutExtension(SchematicPath);

        public double SampleRate
        {
            get { return _sampleRate; }
            set
            {
                if (_sampleRate != value)
                {
                    _sampleRate = value;

                    _needRebuild = true;

                    _delayUpdateSamples = (int)(_sampleRate * .1);
                }
            }
        }

        public int Oversample
        {
            get { return _oversample; }
            set
            {
                if (_oversample != value)
                {
                    _oversample = value;

                    _needRebuild = true;
                }
            }
        }

        public int Iterations
        {
            get { return _iterations; }
            set
            {
                if (_iterations != value)
                {
                    _iterations = value;

                    _needRebuild = true;
                }
            }
        }

        double _sampleRate;
        int _oversample = 2;
        int _iterations = 8;

        Circuit.Circuit _circuit;
        Simulation _simulation;
        bool _needUpdate;
        bool _needRebuild;
        int _updateSamplesElapsed;
        int _delayUpdateSamples;
        Exception _simulationUpdateException;

        public SimulationProcessor()
        {
            InteractiveComponents = new ObservableCollection<ComponentViewModel>();

            SampleRate = 44100;
        }

        public void LoadSchematic(string path)
        {
            Schematic newSchematic = Schematic.Load(path);

            var circuit = newSchematic.Build();

            SetCircuit(circuit);

            Schematic = newSchematic;

            SchematicPath = path;
        }

        public void ClearSchematic()
        {
            Schematic = null;
            SchematicPath = "";
            _circuit = null;
            InteractiveComponents.Clear();
        }

        void SetCircuit(Circuit.Circuit circuit)
        {
            _circuit = circuit;

            InteractiveComponents.Clear();

            Dictionary<string, ButtonGroupViewModel> buttonGroups = new Dictionary<string, ButtonGroupViewModel>();

            foreach (var component in circuit.Components)
            {
                switch (component)
                {
                    case IPotControl pot:
                        InteractiveComponents.Add(new PotViewModel(pot, component.Name));
                        break;

                    case IButtonControl button:
                        if (string.IsNullOrEmpty(button.Group))
                        {
                            InteractiveComponents.Add(new ButtonGroupViewModel(component.Name, button));
                        }
                        else if (buttonGroups.TryGetValue(button.Group, out var wrapper))
                        {
                            wrapper.AddButton(button);
                        }
                        else
                        {
                            wrapper = new ButtonGroupViewModel(button.Group, button);
                            buttonGroups.Add(button.Group, wrapper);
                            InteractiveComponents.Add(wrapper);
                        }
                        break;
                }
            }

            _needRebuild = true;
        }

        /// <summary>
        /// Run the circuit simulation on a buffer of audio samples
        /// </summary>
        /// <param name="audioInputs">Arrays of input samples</param>
        /// <param name="audioOutputs">Arrays of output samples</param>
        /// <param name="numSamples">Number of samples to process</param>
        public void RunSimulation(double[][] audioInputs, double[][] audioOutputs, int numSamples)
        {
            // Throw any exception generated by asynchronous simulation updates
            if (_simulationUpdateException != null)
            {
                Exception toThrow = _simulationUpdateException;

                _simulationUpdateException = null;

                throw toThrow;
            }

            if (_simulation == null && _needRebuild && _circuit != null)
            {
                UpdateSimulation(_needRebuild);

                _needRebuild = false;
            }

            if ((_circuit == null) || (_simulation == null))
            {
                audioInputs[0].CopyTo(audioOutputs[0], 0);
            }
            else
            {
                lock (sync)
                {
                    foreach (ComponentViewModel component in InteractiveComponents)
                    {
                        if (component.NeedUpdate)
                        {
                            _needUpdate = true;

                            component.NeedUpdate = false;

                            _updateSamplesElapsed = 0;
                        }

                        if (component.NeedRebuild)
                        {
                            _needRebuild = true;

                            component.NeedRebuild = false;
                        }
                    }

                    if (_needUpdate || _needRebuild)
                    {
                        // Delay updates until user input settles
                        if (_needRebuild || (_updateSamplesElapsed > _delayUpdateSamples))
                        {
                            UpdateSimulation(_needRebuild);

                            _needRebuild = false;
                            _needUpdate = false;
                        }
                        else
                        {
                            _updateSamplesElapsed += numSamples;
                        }
                    }

                    _simulation.Run(numSamples, audioInputs, audioOutputs);
                }
            }
        }

        int clock = -1;
        int update;
        TaskScheduler scheduler = new RedundantTaskScheduler(1);
        object sync = new object();

        /// <summary>
        /// Update the simulation asynchronously
        /// </summary>
        /// <param name="rebuild">Whether a full simulation rebuild is required</param>
        void UpdateSimulation(bool rebuild)
        {
            int id = Interlocked.Increment(ref update);
            new Task(() =>
            {
                try
                {
                    Analysis analysis = _circuit.Analyze();
                    TransientSolution ts = TransientSolution.Solve(analysis, (Real)1 / (_sampleRate * _oversample));

                    lock (sync)
                    {
                        if (id > clock)
                        {
                            if (rebuild)
                            {
                                Expression inputExpression = _circuit.Components.OfType<Input>().Select(i => i.In).SingleOrDefault();

                                if (inputExpression == null)
                                {
                                    _simulationUpdateException = new NotSupportedException("Circuit has no inputs.");
                                }
                                else
                                {
                                    IEnumerable<Speaker> speakers = _circuit.Components.OfType<Speaker>();

                                    Expression outputExpression = 0;

                                    // Output is voltage drop across the speakers
                                    foreach (Speaker speaker in speakers)
                                    {
                                        outputExpression += speaker.Out;
                                    }

                                    if (outputExpression.EqualsZero())
                                    {
                                        _simulationUpdateException = new NotSupportedException("Circuit has no speaker outputs.");
                                    }
                                    else
                                    {
                                        _simulation = new Simulation(ts)
                                        {
                                            Oversample = _oversample,
                                            Iterations = _iterations,
                                            Input = new[] { inputExpression },
                                            Output = new[] { outputExpression }
                                        };
                                    }
                                }
                            }
                            else
                            {
                                _simulation.Solution = ts;
                                clock = id;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    _simulationUpdateException = ex;
                }

            }). Start(scheduler);
        }
    }
}
